<!DOCTYPE html>
<html lang="en">
<head>
	<style>
	canvas{
	background-color: rgba(0,0,0,0.8);
	width: 100%;
	height: 100%;
        padding: 25px;
         }
	</style>
</head>
<body>
	<canvas id="chart" ></canvas>
	<div id='info'></div>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script type="text/javascript">
const canvas = document.querySelector('#chart')
		windowWidth = window.innerHeight;
        windowHeight = window.innerWidth;
	     ctx = document.querySelector('#chart').getContext('2d');
        value = []
        validvalue = []
        toolTipDiv = document.querySelector('#customToolTip');
        let maxvalue,minvalue,data, newdata;

         let valuesing = parseInt(window.getComputedStyle(canvas).getPropertyValue('height'));
         let label = []

        async function fetchData(){
		await fetch("https://financialmodelingprep.com/api/v3/historical-chart/1min/KEYS?apikey=c38b723e031c88753f0c9e66f505f557").then(res =>res.json()).then(info =>data = info).then(()=>console.log(data))
		formatData()
		createChart()

        }
		function formatData(){	
		newdata = Object.entries(data).sort((([,a],[,b]) =>{
			return new Date(a.date) - new Date(b.date)
        }
        ))
        newdata.forEach((item,index)=>{
        	//if(index <500){
        	const nowdate = new Date();
			const date = new Date(item[1].date);
			if(nowdate.getDate() === date.getDate()){
	        
			label.push(date.getHours())


		    validvalue.push(item[1])
		    const price = ((item[1].close + item[1].open)/2).toFixed(2)
			value.push(price)
			
		}
		})
		//only leave unique item in label
       
		maxvalue = Math.max.apply(null,value)
		minvalue = Math.min.apply(null,value)
		//ternary statement only accept expression, so something like statement ? return .... : return ... will not work
		label = label.map(i=>{
			return (i<12 ? `${i}am` : `${i}pm`)
		})
		}




function finddata(){
  				const latestdate = new Date(newdata[newdata.length-1][1].date).getDate()
		for (let i =newdata.length-1;i>=0;i--){
			if( new Date(newdata[newdata.length-1][1].date).getDate()!= new Date(newdata[i][1].date).getDate()){
			
				return newdata[i][1].close;
			}
		} 
}

function returnColor(){
	//current stock price 
	const currentprice = newdata[0][1].close
	if(currentprice >= finddata()){
		return "lawngreen"
	}else{
		return "red"
	}
}


function linearGarident(color){
	console.log(color)
	  const gradient = ctx.createLinearGradient(0,0,0,valuesing)
	  if(color){
       	gradient.addColorStop(0,"#52c4fa");
        gradient.addColorStop(0.5,"rgba(82,196,250,0.2)");
       gradient.addColorStop(1,'transparent')
       }
	  else if(returnColor().includes("red")){
        gradient.addColorStop(0,"rgba(255,0,0,0.8)");
        gradient.addColorStop(0.35,"rgba(255,0,0,0.3)");
       gradient.addColorStop(1,'transparent')
   }else if (returnColor().includes("green")){
   	    gradient.addColorStop(0,"rgba(0,255,0,0.8)");
        gradient.addColorStop(0.35,"rgba(0,255,0,0.3)");
       gradient.addColorStop(1,'transparent')
   }

   
   console.log(gradient)
   return gradient

}
		function createChart(){

const ctx = document.getElementById('chart').getContext('2d');
        	const annotation = {
    		id:'annotationline',
        	beforeDraw: chart =>{
        		this.tool = chart.tooltip
        		if(this.tool._active && this.tool._active.length){
        			const context =  chart.ctx
        			context.save();
        			const hoverpoint = this.tool._active[0];
        			ctx.setLineDash([])
        			context.beginPath();

        			context.moveTo(this.tool._active[0].element.x,chart.chartArea.top);
        			context.lineTo(this.tool._active[0].element.x,chart.chartArea.bottom);
        			 context.lineWidth =2.5;
        			context.strokeStyle = '#52c4fa';


        			
        			context.stroke();
        			context.restore()
        			context.moveTo(this.tool._active[0].element.x, this.tool._active[0].element.y)
        			context.globalCompositeOperation='destination-over';
        			context.arc(this.tool._active[0].element.x, this.tool._active[0].element.y,12.5,0,2*Math.PI)

        			context.fillStyle = '#52c4fa';
        			context.fill()
        		

 
    
    }
}
}
var horizonalLinePlugin = {
    id: 'horizontalLine',
    order:500,
    afterDraw: function(chartInstance) {
    var yScale = chartInstance.scales["y"];
    var index;
    var line;
    var style; 

    if (chartInstance.options.horizontalLine) {
      for (index = 0; index < chartInstance.options.horizontalLine.length; index++) {
        line = chartInstance.options.horizontalLine[index];
       
        style ='white'

        if (line.y) {
          yValue = yScale.getPixelForValue(line.y);
        } else {
          yValue = 0;
        }

        ctx.lineWidth = 3;

        if (yValue) {
        	 ctx.setLineDash([5, 3])
          ctx.beginPath();

          ctx.moveTo(0, yValue);
          ctx.lineTo(document.querySelector('#chart').width, yValue);
          ctx.strokeStyle = style;
          ctx.stroke();
        }

        if (line.text) {
          ctx.fillStyle = style;
          ctx.fillText("Previous price", 0, yValue + ctx.lineWidth+8);
          ctx.fillText(line.text, 0, yValue + ctx.lineWidth+20);
        }
      }
      return;
    }
  }
};


Chart.register(horizonalLinePlugin);
const myChart = new Chart(ctx, {
    type: 'line',

    data: {
        labels: label,
        datasets: [{
            label: 'stock price',
            data: value,
            fill: true,
            backgroundColor: linearGarident(),
            pointHoverRadius: 0,
             hoverBackgroundColor:linearGarident('color'),
             hoverBorderColor:"rgba(82,196,250,0.8)",
            borderColor:returnColor(),
            order:2

        }]
    },
    options: {
    	tooltips: {enabled: false},
hover: {mode: null},
        "horizontalLine": [{
      "y": finddata(),
      "text":finddata()
    }],
    legend: {
            display: false
         },

    	interaction: {
            mode: 'index',
                  intersect: false,

        },
    	elements:{
    		point:{
    			radius:0,
    			pointHoverRadius: 5
    		},
    		line:{
    			borderWidth:3.5
    		}
    	},
        hover:{
           mode:'dataset',
           intersect:false,

        },
        scales: {
        	y:{
               max: Math.ceil(maxvalue),
               min: Math.floor(minvalue),
               grid:{
               	color:'rgba(255,255,255,0.4)'           	
               },
               ticks:{     
               maxTicksLimit:5
               }
            
        	},
        	x:{
        		grid:{
        			color:"rgba(255,255,255,0.4)"
        		},
        		ticks:{
        			//get number of unqiue item in y label
        			maxTicksLimit:[...new Set(label)].length
        		}
        	}
      
        },
        plugins: {
        	legend:{
        		display:false
        	},
        	tooltip:{
        		yAlign: "bottom",
        		order:2,
        		backgroundColor:'transparent',
        		titleColor:'transparent',
        		displayColors:false,
        		bodyColor:'transparent',
        		footerColor:'transparent',
             callbacks: {
    label: function(tooltipItem, data) {
    	console.log(tooltipItem);
    	console.log(validvalue[tooltipItem.dataIndex])
    	document.querySelector('#info').textContent = tooltipItem.raw+validvalue[tooltipItem.dataIndex].date
					return tooltipItem;
     
    }
},
        	}
        }
    },
    plugins: [annotation]

});
}
		
		window.onload =fetchData;



	</script>
</body>
</html>
