<!DOCTYPE html>
<html lang="en">
<head>
	<style>canvas{
	background-color: rgba(0,0,0,0.8);
	width: 100%;
	padding: 25px;
}</style>
</head>
<body>
	<canvas id="chart" ></canvas>
	<div id='info'></div>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script type="text/javascript">
		const canvas = document.querySelector('#chart')
		windowWidth = window.innerHeight;
        windowHeight = window.innerWidth;
	     ctx = document.querySelector('#chart').getContext('2d');
        label = []
        value = []
        validvalue = []
        toolTipDiv = document.querySelector('#customToolTip');
        let maxvalue,minvalue,data, newdata;

        console.log(windowWidth)
        console.log(windowHeight)

         let valuesing = parseInt(window.getComputedStyle(canvas).getPropertyValue('height'))
         console.log(valuesing)

        async function fetchData(){
		await fetch("https://financialmodelingprep.com/api/v3/historical-chart/1min/KEYS?apikey=c38b723e031c88753f0c9e66f505f557").then(res =>res.json()).then(info =>data = info).then(()=>console.log(data))
		formatData()
		createChart()

        }
		function formatData(){	
		newdata = Object.entries(data).sort((([,a],[,b]) =>{
			return new Date(a.date) - new Date(b.date)
        }
        ))
        newdata.forEach((item,index)=>{
        	//if(index <500){
        	const nowdate = new Date();
			const date = new Date(item[1].date);
			if(nowdate.getDate() === date.getDate()){
	        
			label.push(date.getHours())


		    validvalue.push(item[1])
		    const price = ((item[1].close + item[1].open)/2).toFixed(2)
			value.push(price)
			
		}
		})
		//only leave unique item in label
       
		maxvalue = Math.max.apply(null,value)
		minvalue = Math.min.apply(null,value)
		console.log(maxvalue)
		}




function finddata(){
  				const latestdate = new Date(newdata[newdata.length-1][1].date).getDate()
		console.log(latestdate)
		for (let i =newdata.length-1;i>=0;i--){
			console.log('x')
			if( new Date(newdata[newdata.length-1][1].date).getDate()!= new Date(newdata[i][1].date).getDate()){
			
				return newdata[i][1].close;
			}
		} 
}

function returnColor(){
	//current stock price 
	const currentprice = newdata[0][1].close
	if(currentprice >= finddata()){
		return "green"
	}else{
		return "red"
	}
}


function linearGarident(){
	  const gradient = ctx.createLinearGradient(0,0,0,valuesing)
	  if(returnColor() == "red"){
        gradient.addColorStop(0,"rgba(255,0,0,0.9)");
        gradient.addColorStop(0.5,"rgba(255,0,0,0.3)");
       gradient.addColorStop(1,'transparent')
   }else{
   	    gradient.addColorStop(0,"rgba(0,255,0,0.9)");
        gradient.addColorStop(0.5,"rgba(0,255,0,0.3)");
       gradient.addColorStop(1,'transparent')

   }
   return gradient

}
		function createChart(){

const ctx = document.getElementById('chart').getContext('2d');
        	const annotation = {
    		id:'annotationline',
        	beforeDraw: chart =>{
        		this.tool = chart.tooltip
        		if(this.tool._active && this.tool._active.length){
        			const context =  chart.ctx
        			context.save();
        			context.fillStyle = 'black'
        			const hoverpoint = this.tool._active[0];
        			ctx.setLineDash([])
        			context.beginPath();
        			context.moveTo(this.tool._active[0].element.x,chart.chartArea.top);
        			context.lineTo(this.tool._active[0].element.x,chart.chartArea.bottom)
        			context.lineWidth =10;

        			context.strokeStyle = 'black';
        			context.stroke();
        			context.restore()
    
    }
}
}
var horizonalLinePlugin = {
    id: 'horizontalLine',
    afterDraw: function(chartInstance) {
    var yScale = chartInstance.scales["y"];
    // chartInstance.chart is undefined
    //var ctx = chartInstance.chart;
   // console.log(ctx);
   // var ctx = ctx.ctx;
    var index;
    var line;
    var style; 

    if (chartInstance.options.horizontalLine) {
      for (index = 0; index < chartInstance.options.horizontalLine.length; index++) {
        line = chartInstance.options.horizontalLine[index];
       
        style ='white'

        if (line.y) {
          yValue = yScale.getPixelForValue(line.y);
        } else {
          yValue = 0;
        }

        ctx.lineWidth = 3;

        if (yValue) {
        	 ctx.setLineDash([5, 3])
          ctx.beginPath();

          ctx.moveTo(0, yValue);
          ctx.lineTo(document.querySelector('#chart').width, yValue);
          ctx.strokeStyle = style;
          ctx.stroke();
        }

        if (line.text) {
          ctx.fillStyle = style;
          ctx.fillText("Previous price", 0, yValue + ctx.lineWidth+8);
          ctx.fillText(line.text, 0, yValue + ctx.lineWidth+20);
        }
      }
      return;
    }
  }
};


Chart.register(horizonalLinePlugin);
const myChart = new Chart(ctx, {
    type: 'line',

    data: {
        labels: label,
        datasets: [{
            label: 'stock price',
            data: value,
            fill: true,
            backgroundColor: linearGarident(),
            pointHoverRadius: 0,
             hoverBackgroundColor:'red',
             hoverBorderColor:'green',
            borderColor:returnColor()

        }]
    },
    options: {
    	tooltips: {enabled: false},
hover: {mode: null},
        "horizontalLine": [{
      "y": finddata(),
      "text":finddata()
    }],

    	interaction: {
            mode: 'index',
                  intersect: false,

        },
    	elements:{
    		point:{
    			radius:0,
    			pointHoverRadius: 5
    		}
    	},
        hover:{
           mode:'dataset',
           intersect:false,

        },
        scales: {
        	y:{
               max: Math.ceil(maxvalue),
               min: Math.floor(minvalue),
               grid:{
               	color:'rgba(255,255,255,0.4)'           	
               },
               ticks:{     
               maxTicksLimit:5
               }
            
        	},
        	x:{
        		grid:{
        			color:"rgba(255,255,255,0.4)"
        		},
        		ticks:{
        			//get number of unqiue item in y label
        			maxTicksLimit:[...new Set(label)].length
        		}
        	}
      
        },
        plugins: {
        	tooltip:{
        		yAlign: "bottom",
        		backgroundColor:'transparent',
        		titleColor:'transparent',
        		displayColors:false,
        		bodyColor:'transparent',
        		footerColor:'transparent',
             callbacks: {
    label: function(tooltipItem, data) {
    	console.log(tooltipItem);
    	console.log(validvalue[tooltipItem.dataIndex])
    	document.querySelector('#info').textContent = tooltipItem.raw+validvalue[tooltipItem.dataIndex].date
					return tooltipItem;
     
    }
},
        	}
        }
    },
    plugins: [annotation]

});
}
		
		window.onload =fetchData;

		



	</script>
</body>
</html>
